// Copyright (C) 2014 The Syncthing Authors.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at https://mozilla.org/MPL/2.0/.

// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"text/template"
	"time"

	"github.com/foobaz/go-zopfli/zopfli"
	"golang.org/x/sync/errgroup"
)

var tpl = template.Must(template.New("assets").Parse(`// Code generated by genassets.go - DO NOT EDIT.

package auto

const Generated int64 = {{.Generated}}

func Assets() map[string][]byte {
	var assets = make(map[string][]byte, {{.Assets | len}})
{{range $asset := .Assets}}
	assets["{{$asset.Name}}"] = {{$asset.Data}}{{end}}
	return assets
}

`))

type asset struct {
	Name string
	Data string
}

func walkerFor(basePath string, files chan<- string) filepath.WalkFunc {
	return func(name string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if strings.HasPrefix(filepath.Base(name), ".") {
			// Skip dotfiles
			return nil
		}

		if info.Mode().IsRegular() {
			files <- name
		}

		return nil
	}
}

func newAsset(name, basePath string) (*asset, error) {
	data, err := ioutil.ReadFile(name)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	options := zopfli.DefaultOptions()
	err = zopfli.GzipCompress(&options, data, &buf)
	if err != nil {
		panic(err)
	}

	name, _ = filepath.Rel(basePath, name)
	return &asset{
		Name: filepath.ToSlash(name),
		Data: fmt.Sprintf("[]byte(%q)", buf.String()),
	}, nil
}

type templateVars struct {
	Assets    []*asset
	Generated int64
}

func main() {
	outfile := flag.String("o", "", "Name of output file (default stdout)")
	flag.Parse()

	var g errgroup.Group
	nproc := runtime.GOMAXPROCS(0)
	files := make(chan string, 2*nproc)

	basePath := flag.Arg(0)
	g.Go(func() error {
		defer close(files)
		return filepath.Walk(basePath, walkerFor(basePath, files))
	})

	// Generated time is now, except if the SOURCE_DATE_EPOCH environment
	// variable is set (for reproducible builds).
	generated := time.Now().Unix()
	if s, _ := strconv.ParseInt(os.Getenv("SOURCE_DATE_EPOCH"), 10, 64); s > 0 {
		generated = s
	}

	var (
		assets []*asset
		mu     sync.Mutex
	)

	for i := 0; i < nproc; i++ {
		g.Go(func() error {
			for name := range files {
				a, err := newAsset(name, basePath)
				if err != nil {
					return err
				}

				mu.Lock()
				assets = append(assets, a)
				mu.Unlock()
			}

			return nil
		})
	}

	err := g.Wait()
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	sort.Slice(assets, func(i, j int) bool {
		return assets[i].Name < assets[j].Name
	})

	var buf bytes.Buffer
	tpl.Execute(&buf, templateVars{
		Assets:    assets,
		Generated: generated,
	})
	bs, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	out := io.Writer(os.Stdout)
	if *outfile != "" {
		out, err = os.Create(*outfile)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
	}
	out.Write(bs)
}
